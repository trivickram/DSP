EXP-1:
1. Array of 10 numbers stored in memory location 40h to 49h.Find the average of odd numbers only.

MOV R0,#40H
MOV R2,#10H
MOV R3,#00H
L1:MOV B,@R0
JNB B.0,EVEN
ADD A,B
INC R3
EVEN:INC R0
DJNZ R2,L1
MOV B,R3
DIV AB
END

2.FIND THE SMALLEST NUMBER IN THE GIVEN ARRAY 40H TO 49H
MOV A,40H
MOV R0,#41H
MOV R5,#04H
L2:MOV B,@R0
CJNE A,B,L1
SJMP NEXT
L1:JC NEXT
XCH A,B
NEXT:INC R0
DJNZ R5,L2
END



EXP-2 GPA CALCULATOR
ORG 0000H
	MOV R2,#10
	MOV R0,#50H
	MOV R1,#40H
	MOV DPTR,#3000H
	LABEL1:MOV A,@R0
	MOV B,@R1
	MUL AB
	MOVX @DPTR,A
	ADDC A,R3
	MOV R3,A
	MOV A,R4
	ADDC A,@R1
	MOV R4,A
	INC R0
	INC R1
	INC DPTR
	DJNZ R2,LABEL1
	MOV A,R3
	MOV B,R4
	DIV AB
	END


credits in 40h 
points in 50h (in hex)




exp3.PROGRAMMING IN IO PORTS
1.To generate a square wave with 75% duty cycle and p1.0
ORG 0000H
CLR P1.0
AGAIN:SETB P1.0
ACALL DELAY
ACALL DELAY
ACALL DELAY
CLR P1.0
ACALL DELAY
SJMP AGAIN
DELAY: MOV R0,#0FFH
L2:MOV R1,#0FFH
L1:DJNZ R1,L1
DJNZ R0,L2
RET 
END

task2  blink led connected at p1 in serial

ORG 0000H
MOV P1,#00H
SETB C
MOV A,#00H
AGAIN: MOV P1,A
RLC A
ACALL DELAY
SJMP AGAIN
DELAY: MOV R0,#55H
L3:MOV R0,#0FFH
L2: MOV R1,#0FFH
L1: DJNZ R1,L1
DJNZ R0,L2
DJNZ R3,L3
RET
END

TASK 3 (blink led in p1 in pattern given)
ORG 0000H
MOV P1,#00H
CLR C
MOV A,#00H
AGAIN: CPL C
MOV P1,A
RLC A
ACALL DELAY
SJMP AGAIN
DELAY: MOV R3,#0FFH
L3:MOV R0,#0FFH
L2: MOV R1,#0FFH
L1: DJNZ R1,L1
DJNZ R0,L2
DJNZ R3,L3
RET
END
 

TASK 4 (blink led in given order)
ORG 0000H
MOV R1,#00H
AGAIN:MOV P1,#10000001B
ACALL DELAY
MOV P1,#01000010B
ACALL DELAY
MOV P1,#00100100B
ACALL DELAY
MOV P1,#00011000B
ACALL DELAY
SJMP AGAIN
DELAY:
MOV R0,#0FFH
L3:MOV R0,#0FFH
L2:MOV R1,#0FFH
L1:DJNZ R1,L1
DJNZ R0,L2
DJNZ R3,L3
RET
END















Exp-4(timer and counter)
To generate a sqaure wave form with 250us on time and 50 off time for a crystal frequency of 22MHz
timer:
ORG 0000H
	MOV TMOD,#010H
	AGAIN: MOV TH1,#0FFH
	MOV TL1,#0A4H
	CLR P1.0
	SETB TR1
	HERE:JNB TF1,HERE
	CLR TF1
	CLR TR1
	MOV TH1,#0FEH
	MOV TL1,#35H
	SETB P1.0
	SETB TR1
	HERE1:JNB TF1,HERE1
	CLR TF1
	CLR TR1
	SJMP AGAIN
	END
  

COUNTER:To count external pulse supplied to p3.5 upto the value FF and load the count value in p1
ORG 0000H
	MOV TMOD ,#60H
	MOV TH1,#00H
	
	AGAIN:CLR P1.0
	SETB P3.5
	SETB TR1
	L1:
	MOV A,TL1
	MOV P1,A
	JNB TF1,L1
	CLR TF1
	CLR TR1
	SJMP AGAIN
	END



exp 5 
task 1: square wave generator

ORG 0000H
	MOV TMOD,#010H
AGAIN:MOV TH1,#0FFH
	MOV TL1,#0A9H
	SETB P1.0
	SETB TR1
HERE: JNB TF1, HERE
	CLR TF1
    CLR TR1
    MOV TH1,#0FEH
    MOV TL1,#35H
    CLR P1.0
    SETB TR1
HERE1: JNB TF1,HERE1
    CLR TF1
    CLR TR1
    SJMP AGAIN
    END

task-2:ports
ORG 0000H
	AGAIN: MOV P1, #10000001B
ACALL DELAY
MOV P1,#00000000B
ACALL DELAY
MOV P1,#01000010B
ACALL DELAY
MOV P1,#00000000B
ACALL DELAY
MOV P1,#00100100B
ACALL DELAY
MOV P1,#00000000B
ACALL DELAY
MOV P1,#00011000B
ACALL DELAY
SJMP AGAIN
DELAY:MOV R3,#0FFH
L3:MOV R0,#0FFH
L2: MOV R1,#0FFH
L1:DJNZ R1,L1
DJNZ R0,L2
DJNZ R3,L3
RET
END




exp 6 SERIAL COMMUNICATION :a led is connected to p1.0,check the status of the led.if,its on transmit messege 'led on' and if not transmit messege 'led off'.

ORG 0000H
MOV TMOD,#20H
MOV TH1,#-12D
MOV SCON,#50H
AGAIN:SETB TR1
      JB P1.0,LEDON
      MOV DPTR,#MESSAGE2
   L2:CLR A
      MOVC A,@A+DPTR 
      JZ EXIT
      ACALL SERIAL
      INC DPTR
      SJMP L2
	  CLR TR1
	  EXIT:SJMP AGAIN
      LEDON:MOV DPTR,#MESSAGE1
   L1:CLR A
      MOVC A,@A+DPTR
      JZ EXIT
      ACALL SERIAL
      INC DPTR
      SJMP L1
SERIAL:MOV SBUF,A
  HERE:JNB TI,HERE
       CLR TI
       RET
ORG 300H
       MESSAGE1:DB "LEDON",0
       MESSAGE2:DB"LEDOFF",0 
		   END  

exp 7 intterupts with lcd

TASK-1:To blink led connected to port p1.5 when there is no interrupt and to blink led to p1.0,when there is interrupt p3.2 with edge triggerind
ORG 0000H
SJMP 0030H
ORG 0030H
MOV IE,#84H
SETB TCON.2
SETB P1.5
AGAIN:ACALL DELAY
CPL P1.5
SJMP AGAIN
ORG 013H
SJMP 0050H
ORG 0050
SETB P1.0
ACALL DELAY
CLR P1.0
ACALL DELAY
RETI
DELAY:MOV R2,#010H
L3:MOV R0,#0FFH
L2:MOV R1,#0FFH
L1:DJNZ R1,L1
DJNZ R0,L2
DJNZ R2,L3
RET
END


TASK-2:Display messege "Interrupt has occured"when edge triggered occur at int1

ORG 00BH
SJMP 0050H
ORG 0050H
AGAIN:MOV DPTR,#MYCOM
BACK:CLR A
MOVC A,@A+DPTR
JZ DATAS
ACALL COMSUB
ACALL DELAY
INC DPTR
SJMP BACK
DATAS:MOV DPTR,#MYDATA
BACK1:CLR A
MOVC A,@A+DPTR
JZ AGAIN 
ACALL DATASUB
ACALL DELAY
INC DPTR
SJMP BACK1
RETI
COMSUB:CLR P3.7
CLR P3.6
RET
DATASUB:SETB P3.7
CLR P3.6
SETB P3.5
MOV P2,A
CLR P3.5
RET
DELAY:MOV R1,#0FFH
L1:MOV R0,#0FFH
HERE:DJNZ R0,HERE
DJNZ R1,L1
RET
ORG 0500H
MYCOM:DB '38H,01H,0EH,06H,30H,0'
MYDATA:DB"INTERRUPT HAS OCCUERED",0
END


exp 8 keypad  4x4
 
ORG 0000H                             ; ORIGIN to load program in 0H
SJMP START                            ;short jump to label start


           ORG 0030H             
           START:MOV P0,#0FFH          ; make P2 an input port
           ACALL LCD_INITIALIZE          ; call LCD_INITIALIZE  
           K1:MOV P1,#0                       ; ground all rows at once
           MOV A,P0                           ; read all keys(ensure open)
           ANL A,#00001111B               ; mask unused bits
           CJNE A,#00001111B,K1        ; till all keys release
         


         K2:ACALL DELAY                     ; call 20 msec delay
           MOV A,P0                                ; see if any key is pressed
           ANL A,#00001111B                 ; mask unused bits
           CJNE A,#00001111B,OVER    ; key pressed,find row
           SJMP K2                                     ; check till key pressed
          

         OVER:ACALL DELAY                 ; wait 20 msecdebounce time
           MOV A,P0                                  ; check key closure
           ANL A,#00001111B                  ; mask unused bits
           CJNE A,#00001111B,OVER1     ; key pressed,find row
           SJMP K2                                         ; of none, keep polling
           

        OVER1:MOV P1,#11111110B     ; ground row 0
           MOV A,P0                                      ; read all columns
           ANL A,#00001111B                      ; mask unused bits
           CJNE A,#00001111B,ROW_0      ; key row 0, find column
           MOV P1,#11111101B                   ; ground row 1
        MOV A,P0                                      ; read all columns
        ANL A,#00001111B                      ; mask unused bits
        CJNE A,#00001111B,ROW_1      ; key row 1, find column
           MOV P1,#11111011B                    ; ground row 2
           MOV A,P0                                        ; read all columns
           ANL A,#00001111B                        ; mask unused bits
           CJNE A,#00001111B,ROW_2        ; key row 2, find column
           MOV P1,#11110111B                    ; ground row 3
           MOV A,P0                                          ; read all columns
           ANL A,#00001111B                          ; mask unused bits
           CJNE A,#00001111B,ROW_3          ; key row 3, find column
           LJMP K2                                          ; if none ,false input ,repeat
           


          ROW_0:MOV DPTR,#KCODE0         ; set DPTR=start of row 0
           SJMP FIND                                    ; find column key belongs to
           ROW_1:MOV DPTR,#KCODE1        ; set DPTR=start of row 1
           SJMP FIND                                    ; find column key belongs to
           ROW_2:MOV DPTR,#KCODE2         ; set DPTR=start of row 2
           SJMP FIND                                    ; find column key belongs to
           ROW_3:MOV DPTR,#KCODE3         ; set DPTR=start of row 3
          

         FIND:RRC A                                         ; see if any CY bit is low
           JNC MATCH                                         ; if zero get ASCII code
           INC DPTR                                             ; point to next column
           SJMP FIND                                           ; keep searching
          

        MATCH:CLR A                                     ; set A=0 (match is found)
           MOVC A,@A+DPTR                           ; get ASCII from table
           ACALL LCD_DATA                       ; call LCD_DATA subroutine
           LJMP K1                                               ; long jump to K1(loop)



           LCD_INITIALIZE:                        ; LCD_INITIALIZE subroutine
           MOV A,#38H                                      ; initialize 16x2 LCD
ACALL LCD_COMMAND                  ; call LCD_COMMAND subroutine
MOV A,#0EH                                     ; display on, cursor on
ACALL LCD_COMMAND                 ; call LCD_COMMAND subroutine
           MOV A,#01H                                     ; clear LCD
           ACALL LCD_COMMAND                  ; call LCD_COMMAND subroutine
           MOV A,#06H                                     ; shift cursor right
           ACALL LCD_COMMAND                  ; call LCD_COMMAND subroutine
           MOV A,#80H                                    ; force cursor to the beginning of first line
           ACALL LCD_COMMAND                ; call LCD_COMMAND subroutine
           RET                                                   ; return from LCD_INITIALIZE subroutine
           LCD_COMMAND:                          ; LCD_COMMAND subroutine
           MOV P2,A                                        ; copy reg A to port 2
           CLR P3.7                                           ; RS=0 for command
           CLR P3.6                                           ; R/W=0 for write
           SETB P3.5                                         ; E=1 for high pulse
           ACALL DELAY                                   ; give LCD sometime
           CLR P3.5                                           ; E=0 for H-to-L pulse
           RET                                                  ; return from LCD_COMMAND subroutine
           LCD_DATA:                                    ; LCD_DATA subroutine
           MOV P2,A                                      ; copy reg A to port 2
           SETB P3.7                                       ; RS=0 for command
           CLR P3.6                                         ; R/W=0 for write
           SETB P3.5                                       ; E=1 for high pulse
           ACALL DELAY                                ; give LCD sometime
           CLR P3.5                                        ; E=0 for H-to-L pulse
           RET                                               ; return from LCD_DATA subroutine
            DELAY:MOV R4,#40                   ; R4=40
            HERE:MOV R5,#230                  ; R5=230
           HERE1:DJNZ R5,HERE1             ; stay until R5 becomes 0
DJNZ R4,HERE                           ; stay until R4 becomes 0
RET                                              ; return from DELAY subroutine
ORG 300H                                          ; ASCII look-up table for each row
                       KCODE3:DB 'C','D','E','F'     ; row 3
                       KCODE2:DB '8','9','A','B'    ; row 2
            KCODE1:DB '4','5','6','7'                                 ; row 1
            KCODE0:DB '0','1','2','3'                                 ; row 0
END                                                          ; end of program
 
4x2:

ORG 0000H                             ; ORIGIN to load program in 0H
SJMP START                            ;short jump to label start


           ORG 0030H             
           START:MOV P0,#0FFH          ; make P2 an input port
           ACALL LCD_INITIALIZE          ; call LCD_INITIALIZE  
           K1:MOV P1,#0                       ; ground all rows at once
           MOV A,P0                           ; read all keys(ensure open)
           ANL A,#00000011B               ; mask unused bits
           CJNE A,#00000011B,K1        ; till all keys release
         


         K2:ACALL DELAY                     ; call 20 msec delay
           MOV A,P0                                ; see if any key is pressed
           ANL A,#00000011B                 ; mask unused bits
           CJNE A,#00000011B,OVER    ; key pressed,find row
           SJMP K2                                     ; check till key pressed
          

         OVER:ACALL DELAY                 ; wait 20 msecdebounce time
           MOV A,P0                                  ; check key closure
           ANL A,#00000011B                  ; mask unused bits
           CJNE A,#00000011B,OVER1     ; key pressed,find row
           SJMP K2                                         ; of none, keep polling
           

        OVER1:MOV P1,#11111110B     ; ground row 0
           MOV A,P0                                      ; read all columns
           ANL A,#00000011B                      ; mask unused bits
           CJNE A,#00000011B,ROW_0      ; key row 0, find column
           MOV P1,#11111101B                   ; ground row 1
        MOV A,P0                                      ; read all columns
        ANL A,#00000011B                      ; mask unused bits
        CJNE A,#00000011B,ROW_1      ; key row 1, find column
           MOV P1,#11111011B                    ; ground row 2
           MOV A,P0                                        ; read all columns
           ANL A,#00000011B                        ; mask unused bits
           CJNE A,#00000011B,ROW_2        ; key row 2, find column
           MOV P1,#11110111B                    ; ground row 3
           MOV A,P0                                          ; read all columns
           ANL A,#00000011B                          ; mask unused bits
           CJNE A,#00000011B,ROW_3          ; key row 3, find column
           LJMP K2                                          ; if none ,false input ,repeat
           


          ROW_0:MOV DPTR,#KCODE0         ; set DPTR=start of row 0
           SJMP FIND                                    ; find column key belongs to
           ROW_1:MOV DPTR,#KCODE1        ; set DPTR=start of row 1
           SJMP FIND                                    ; find column key belongs to
           ROW_2:MOV DPTR,#KCODE2         ; set DPTR=start of row 2
           SJMP FIND                                    ; find column key belongs to
           ROW_3:MOV DPTR,#KCODE3         ; set DPTR=start of row 3
          

         FIND:RRC A                                         ; see if any CY bit is low
           JNC MATCH                                         ; if zero get ASCII code
           INC DPTR                                             ; point to next column
           SJMP FIND                                           ; keep searching
          

        MATCH:CLR A                                     ; set A=0 (match is found)
           MOVC A,@A+DPTR                           ; get ASCII from table
           ACALL LCD_DATA                       ; call LCD_DATA subroutine
           LJMP K1                                               ; long jump to K1(loop)



           LCD_INITIALIZE:                        ; LCD_INITIALIZE subroutine
           MOV A,#38H                                      ; initialize 16x2 LCD
ACALL LCD_COMMAND                  ; call LCD_COMMAND subroutine
MOV A,#0EH                                     ; display on, cursor on
ACALL LCD_COMMAND                 ; call LCD_COMMAND subroutine
           MOV A,#01H                                     ; clear LCD
           ACALL LCD_COMMAND                  ; call LCD_COMMAND subroutine
           MOV A,#06H                                     ; shift cursor right
           ACALL LCD_COMMAND                  ; call LCD_COMMAND subroutine
           MOV A,#80H                                    ; force cursor to the beginning of first line
           ACALL LCD_COMMAND                ; call LCD_COMMAND subroutine
           RET                                                   ; return from LCD_INITIALIZE subroutine
           LCD_COMMAND:                          ; LCD_COMMAND subroutine
           MOV P2,A                                        ; copy reg A to port 2
           CLR P3.7                                           ; RS=0 for command
           CLR P3.6                                           ; R/W=0 for write
           SETB P3.5                                         ; E=1 for high pulse
           ACALL DELAY                                   ; give LCD sometime
           CLR P3.5                                           ; E=0 for H-to-L pulse
           RET                                                  ; return from LCD_COMMAND subroutine
           LCD_DATA:                                    ; LCD_DATA subroutine
           MOV P2,A                                      ; copy reg A to port 2
           SETB P3.7                                       ; RS=0 for command
           CLR P3.6                                         ; R/W=0 for write
           SETB P3.5                                       ; E=1 for high pulse
           ACALL DELAY                                ; give LCD sometime
           CLR P3.5                                        ; E=0 for H-to-L pulse
           RET                                               ; return from LCD_DATA subroutine
            DELAY:MOV R4,#40                   ; R4=40
            HERE:MOV R5,#230                  ; R5=230
           HEREA:DJNZ R5,HEREA             ; stay until R5 becomes 0
DJNZ R4,HERE                           ; stay until R4 becomes 0
RET                                              ; return from DELAY subroutine
ORG 300H                                          ; ASCII look-up table for each row
                       KCODE3:DB '7','6'     ; row 3
                       KCODE2:DB '5','4'    ; row 2
            KCODE1:DB '3','2'                                 ; row 1
            KCODE0:DB '0','1'                                 ; row 0
END      













2x4:

ORG 0000H                             ; ORIGIN to load program in 0H
SJMP START                            ;short jump to label start


           ORG 0030H             
           START:MOV P0,#0FFH          ; make P2 an input port
           ACALL LCD_INITIALIZE          ; call LCD_INITIALIZE  
           K1:MOV P1,#0                       ; ground all rows at once
           MOV A,P0                           ; read all keys(ensure open)
           ANL A,#00001111B               ; mask unused bits
           CJNE A,#00001111B,K1        ; till all keys release
         


         K2:ACALL DELAY                     ; call 20 msec delay
           MOV A,P0                                ; see if any key is pressed
           ANL A,#00001111B                 ; mask unused bits
           CJNE A,#00001111B,OVER    ; key pressed,find row
           SJMP K2                                     ; check till key pressed
          

         OVER:ACALL DELAY                 ; wait 20 msecdebounce time
           MOV A,P0                                  ; check key closure
           ANL A,#00001111B                  ; mask unused bits
           CJNE A,#00001111B,OVER1     ; key pressed,find row
           SJMP K2                                         ; of none, keep polling
           

        OVER1:MOV P1,#11111110B     ; ground row 0
           MOV A,P0                                      ; read all columns
           ANL A,#00001111B                      ; mask unused bits
           CJNE A,#00001111B,ROW_0      ; key row 0, find column
           MOV P1,#11111101B                   ; ground row 1
        MOV A,P0                                      ; read all columns
        ANL A,#00001111B                      ; mask unused bits
        CJNE A,#00001111B,ROW_1      ; key row 1, find column
           LJMP K2                                          ; if none ,false input ,repeat
           


          ROW_0:MOV DPTR,#KCODE0         ; set DPTR=start of row 0
           SJMP FIND                                    ; find column key belongs to
           ROW_1:MOV DPTR,#KCODE1        ; set DPTR=start of row 1
           SJMP FIND                                    ; find column key belongs to
          

         FIND:RRC A                                         ; see if any CY bit is low
           JNC MATCH                                         ; if zero get ASCII code
           INC DPTR                                             ; point to next column
           SJMP FIND                                           ; keep searching
          

        MATCH:CLR A                                     ; set A=0 (match is found)
           MOVC A,@A+DPTR                           ; get ASCII from table
           ACALL LCD_DATA                       ; call LCD_DATA subroutine
           LJMP K1                                               ; long jump to K1(loop)



           LCD_INITIALIZE:                        ; LCD_INITIALIZE subroutine
           MOV A,#38H                                      ; initialize 16x2 LCD
ACALL LCD_COMMAND                  ; call LCD_COMMAND subroutine
MOV A,#0EH                                     ; display on, cursor on
ACALL LCD_COMMAND                 ; call LCD_COMMAND subroutine
           MOV A,#01H                                     ; clear LCD
           ACALL LCD_COMMAND                  ; call LCD_COMMAND subroutine
           MOV A,#06H                                     ; shift cursor right
           ACALL LCD_COMMAND                  ; call LCD_COMMAND subroutine
           MOV A,#80H                                    ; force cursor to the beginning of first line
           ACALL LCD_COMMAND                ; call LCD_COMMAND subroutine
           RET                                                   ; return from LCD_INITIALIZE subroutine
           LCD_COMMAND:                          ; LCD_COMMAND subroutine
           MOV P2,A                                        ; copy reg A to port 2
           CLR P3.7                                           ; RS=0 for command
           CLR P3.6                                           ; R/W=0 for write
           SETB P3.5                                         ; E=1 for high pulse
           ACALL DELAY                                   ; give LCD sometime
           CLR P3.5                                           ; E=0 for H-to-L pulse
           RET                                                  ; return from LCD_COMMAND subroutine
           LCD_DATA:                                    ; LCD_DATA subroutine
           MOV P2,A                                      ; copy reg A to port 2
           SETB P3.7                                       ; RS=0 for command
           CLR P3.6                                         ; R/W=0 for write
           SETB P3.5                                       ; E=1 for high pulse
           ACALL DELAY                                ; give LCD sometime
           CLR P3.5                                        ; E=0 for H-to-L pulse
           RET                                               ; return from LCD_DATA subroutine
            DELAY:MOV R4,#40                   ; R4=40
            HERE:MOV R5,#230                  ; R5=230
           HEREA:DJNZ R5,HEREA             ; stay until R5 becomes 0
DJNZ R4,HERE                           ; stay until R4 becomes 0
RET                                              ; return from DELAY subroutine
ORG 300H                                          ; ASCII look-up table for each row
            KCODE1:DB '4','5','6','7'                                 ; row 1
            KCODE0:DB '0','1','2','3'                                 ; row 0
END




exp 9
SAW TOOTH:

ORG 0000H
AGAIN:MOV A,#00H
BACK:MOV P1,A
     INC A
     CJNE A,#0FFH,BACK
     SJMP AGAIN
     END

TRIANGULAR:

ORG 0000H
AGAIN:MOV A,#00H
BACK:MOV P1,A
     INC A
     CJNE A,#0FFH,BACK
BACK1:MOV P1,A
      DEC A
      CJNE A,#00H,BACK1
      SJMP AGAIN
      END

STAIRCASE:
ORG 0000H
AGAIN:MOV A,#00H
BACK:MOV P1,A
     ACALL DELAY
     INC A
     CJNE A,#0FFH,BACK
     SJMP AGAIN
DELAY:MOV R0,#0FFH
BACK1:MOV R1,#0FFH
HERE:DJNZ R1,HERE
     DJNZ R0,BACK1
     RET
     END

Aim: To Display the message when Int 0 , display “doctor is in” and when Int 1 ,display  “ doctor is busy. Occurs in main program “doctor yet to come” should be displayed
ORG 0000H	;Initialize program memory at address 0000H
SJMP 0030H	;Jump to the main program
ORG 0030H	;Main program starts at address 0030H
CLR P3.5	;Clear port 3.5
CLR P3.6	;Clear port 3.6
CLR P3.7	;Clear port 3.6
MOV P2, #00H	;Initialize port 2
MOV IE, #10000101B	;Enable interrupts
SETB TCON.2	;Set Timer 1 overflow flag
SETB TCON.0	;Set Timer 0 overflow flag
MOV A, #38H	;Set 8-bit mode for LCD
ACALL CMD	;Send command to LCD
ACALL DLAY	;Delay
MOV A, #OEH	;Turn on cursor display
ACALL CMD	;Send command to LCD
ACALL DLAY	;Delay
MOV A, #01H	;Clear LCD display
ACALL CMD	;Send command to LCD
ACALL DLAY	;Delay
Ag:	MOV A, #080H ;	Set cursor position to 1st line
ACALL CMD	;Send command to LCD
ACALL DLAY	;Delay
MOV DPTR,#M1	;Load address of message M1
ACALL RTLCD	;Display the message
ACALL DLAY	;Delay
ACALL DLAY	;Additional delay
SJMP Ag	;Repeat the loop
CMD: CLR P3.7	;Clear port 3.7
CLR P3.6	;Clear port 3.6
SETB P3.5	;Set port 3.5
MOV P2, A	;Send data to LCD
ACALL DLAY	;Delay
CLR P3.5	;Clear port 3.5
RET	;Return from subroutine
DAT: SETB P3.7	;Set port 3.7
CLR P3.6	;Clear port 3.6
SETB P3.5	;Set port 3.5
MOV P2, A	;Send data to LCD
ACALL DLAY	;Delay
CLR P3.5	;Clear port 3.5
RET	;Return from subroutine
DLAY: MOV R7, #0FFH	;Initialize R7
Back: MOV R6, #0CH	;Initialize R6
Here: DJNZ R6, Here	;Decrement R6 and loop
DJNZ R7, Back	;Decrement R7 and loop
  RET	;Return from subroutine
RTLCD:NOP	;No operation
L1: CLR A	;Clear accumulator
MOVC A,@A+DPTR	;Move code memory to accumulator
JZ OVER	;If zero, jump to OVER
ACALL DAT	;Send data to LCD
ACALL DLAY	;Delay
INC DPTR	;Increment data pointer
SJMP L1	;Repeat the loop
OVER:RET	;Return from subroutine
M1:DB 'Doc. yet to come',0	;Messages
M2:DB 'Doc.   is   in  ',0	;Messages
M3:DB 'Doc.   is   busy',0	;Messages
ORG 0003H	;starting address
LJMP 0250H	;Long jump to the address 0250H
ORG 0250H	;Interrupt service routine for address 0250H
MOV A, #080H	;Set cursor position to 1st line
LCALL CMD	;Send command to LCD
LCALL DLAY	;Delay
MOV DPTR,#M2	;Load address of message M2
LCALL RTLCD	;Display the message
LCALL DLAY	;Delay
RETI	;Return from interrupt
ORG 0013H	;Starting address
LJMP 0300H	;Long jump to the address0013H
ORG 0300H	;Interrupt service routine for address 0300H
MOV A, #080H	;Set cursor position to 1st line
LCALL CMD	;Send command to LCD
LCALL DLAY	;Delay
MOV DPTR,#M3	;Load address of message M3
LCALL RTLCD	;Display the message
LCALL DLAY	;Delay
RETI	;Return from interrupt
END	;End of program







ORG 0000H
	SJMP 0030H
ORG 0030H
	;MOV P3, #0FFH
	MOV IE, #10000100B
	SETB TCON.2
	MOV A, #38H ; 8 bit mode
	ACALL CMD
	ACALL DLAY
	MOV A, #0EH ; display on curson on
	ACALL CMD
	ACALL DLAY
	MOV A, #01H ; clear LCD
	ACALL CMD
	ACALL DLAY
Ag:	MOV A, #080H ;1st line
	ACALL CMD
	ACALL DLAY
	MOV DPTR,#M1
	ACALL RTLCD
	ACALL DLAY
	MOV A, #0C0H ;2nd line
	ACALL CMD
	ACALL DLAY
	MOV DPTR,#M1
	ACALL RTLCD
	ACALL DLAY
	ACALL DLAY
	SJMP Ag


;Command Subroutine
CMD: CLR P3.7
	 CLR P3.6
	 SETB P3.5
	 MOV P2, A
	 ACALL DLAY
	 CLR P3.5
	 RET
;Data Subroutine
DAT: SETB P3.7
	 CLR P3.6
	 SETB P3.5
	 ;SUBB A,#40H
	 MOV P2, A
	 ACALL DLAY
	 CLR P3.5
	 RET
;Delay Subroutine
DLAY: MOV R7, #0FFH
Back: MOV R6, #0CH
Here: DJNZ R6, Here
	  DJNZ R7, Back
	  RET
;Return to LCD Initial Subroutine
RTLCD:NOP
L1: CLR A
	MOVC A,@A+DPTR
	JZ OVER
	;ADD A,#40H
	ACALL DAT
	ACALL DLAY
	INC DPTR
	SJMP L1
OVER:RET

M1:DB '  NO INTERRUPT  ',0
M2:DB '    INTERRUPT   ',0
M3:DB '    OCCURED     ',0

ORG 0013H
LJMP 0200H
ORG 0200H
    MOV A, #080H ;1st line
	LCALL CMD
	LCALL DLAY
	MOV DPTR,#M2
	LCALL RTLCD
	LCALL DLAY
	MOV A, #0C0H ;2nd line
	LCALL CMD
	LCALL DLAY
	MOV DPTR,#M3
	LCALL RTLCD
	LCALL DLAY
RETI

END
